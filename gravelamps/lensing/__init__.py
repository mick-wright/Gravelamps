'''
Gravelamps Lensing Module
Mick Wright 2021

Module contains the functions necessary to construct lensed waveforms as well as generate the data
necessary to perform analysis runs for both local machines and for cluster machines utilising the
HTCondor scheduler platform
'''

import numpy as np
import astropy.constants as const

import bilby

from . import utils

class LensedWaveformGenerator(bilby.gw.waveform_generator.WaveformGenerator):
    '''
    Lensed Waveform Generator Class

    Based upon the general bilby Waveform Generator class, but with the additional requirements for
    files containing the dimensionless frequency and impact parameter arrays as well as the
    amplification factor matrices. Using these, it will then generate the interpolator for use
    by the frequency domain source model
    '''

    def __init__(self, duration=None, sampling_frequency=None, start_time=0,
                 frequency_domain_source_model=None, time_domain_source_model=None,
                 parameters=None, parameter_conversion=None, waveform_arguments=None):

        #Initialise the parent class
        super().__init__(duration, sampling_frequency, start_time, frequency_domain_source_model,
                         time_domain_source_model, parameters, parameter_conversion,
                         waveform_arguments)

        #Extract the files necessary to generate the interpolator
        dimensionless_frequency_file = waveform_arguments["w_array_file"]
        impact_parameter_file = waveform_arguments["y_array_file"]
        amplification_factor_real_file = waveform_arguments["amp_fac_real_file"]
        amplification_factor_imag_file = waveform_arguments["amp_fac_imag_file"]

        #Generate the interpolator and add it to the waveform_arguments dictionary
        waveform_arguments["interpolator"] = utils.generate_interpolator(
            dimensionless_frequency_file, impact_parameter_file, amplification_factor_real_file,
            amplification_factor_imag_file)

def BBH_lensed_waveform(frequency_array, mass_1, mass_2, a_1, a_2, tilt_1, tilt_2, phi_12, phi_jl,
                        luminosity_distance, theta_jn, phase, ra, dec, geocent_time, psi,
                        lens_mass, impact_parameter, lens_fractional_distance, **kwargs):
    '''
    Inputs:
        frequency_array - frequencies over which to generate waveform
        mass_1 - non-redshifted primary mass in solar masses
        mass_2 - non-redshifted secondary mass in solar masses
        a_1 - dimensionless spin magnitude of the primary
        a_2 - dimensionless spin magnitude of the secondary
        tilt_1 - polar angle between primary spin and the orbital angular momentum in radians
        tilt_2 - polar angle between secondary spin and the orbital angular momentum in radians
        phi_12 - azimuthal angle bbetween primary and secondary spins in radians
        phi_jl - azimuthal angle between total angular momentum and the orbital angular momentum
                 in radians
        luminosity_distance - luminosity distance to the source in Mpc
        theta_jn - inclination angle between line-of-sight and the orbital angular momentum in
                   radians
        phase - phase in radians
        ra - right ascension of the source in radians
        dec - declination of the source in radians
        geocent_time - time of coalescene or peak amplitude in GPS seconds
        psi - gravitational wave polarisation angle in radians
        lens_mass - non-redshifted mass of the lensing object in solar masses
        impact_parameter - distance between wave and the lensing object at closest approach in
                           natural units
        lens_fractional_distance - fractional position of the lens compared to the luminosity
                                   distance

        **kwargs:
            waveform_approximant - the waveform approximant used to generate teh base waveform
            reference_frequency - the waveform reference frequency in Hz
            minimum_frequency - the waveform minimum frequency in Hz
            interpolator - interpolating function to generate the amplification factor used to lens
                           the base waveform

    Outputs:
        lens_waveform - dictionary containing the plus and cross polarisation mode strain data for
                        the lensed waveform

    Function takes a base waveform generated by the lal_binary_black_hole function and then lenses
    it by a lens with given mass, at the given impact parameter. The amplification factor is
    generated by m,eans of the given interpolator function
    '''

    #Generate the waveform_kwargs dict and then update it using the given kwargs
    waveform_kwargs = dict(waveform_approximant="IMRPhenomPv2", reference_frequency=50,
                           minimum_frequency=20, interpolator=None)
    waveform_kwargs.update(kwargs)

    #Extract the approximant, reference and minimum frequencies and the interpolator
    waveform_approximant = waveform_kwargs["waveform_approximant"]
    reference_frequency = waveform_kwargs["reference_frequency"]
    minimum_frequency = waveform_kwargs["minimum_frequency"]
    interpolator = waveform_kwargs["interpolator"]

    #Interpolator is necessary, check that it is there
    if interpolator is None:
        raise ValueError("Interpolator must be given!")

    #Calculate the redshifted lens mass
    lens_distance = lens_fractional_distance * luminosity_distance
    lens_redshift = bilby.gw.conversion.luminosity_distance_to_redshift(lens_distance)
    redshifted_lens_mass = natural_mass(lens_mass(1 + lens_redshift))

    #Construct the base waveform using lal_binary_black_hole
    base_waveform = bilby.gw.source.lal_binary_black_hole(frequency_array, mass_1=mass_1,
        mass_2=mass_2, a_1=a_1, a_2=a_2, tilt_1=tilt_1, tilt_2=tilt_2, phi_12=phi_12, phi_jl=phi_jl,
        luminosity_distance=luminosity_distance, theta_jn=theta_jn, phase=phase,
        waveform_approximant=waveform_approximant, reference_frequency=reference_frequency,
        minimum_frequency=minimum_frequency, ra=ra, dec=dec, geocent_time=geocent_time, psi=psi)

    #If the base_waveform function returns a None, return a None
    if base_waveform is None:
        return None

    #Construct the dimensionless frequency array from the frequency arraay
    dimensionless_frequency_array = dimensionless_frequency(frequency_array, redshifted_lens_mass)

    #Now generate the amplification factor array using the interpolator function
    amplification_factor_array = interpolator(dimensionless_frequency_array, impact_parameter)

    #Now create the lens waveform by multiplying the base waveform by thge amplification factor
    #array
    lens_waveform = dict()

    for polarisation in base_waveform:
        lens_waveform[polarisation] = np.multiply(base_waveform[polarisation],
                                                  amplification_factor_array)

    #Return the lensed waveform
    return lens_waveform

def dimensionless_frequency(frequency, redshifted_lens_mass):
    '''
    Inputs:
        frequency - the frequencies to be converted
        redsfhited_lens_mass - the redshifted mass of the lensing object in natural units

    Outputs:
        dim_freq - array containing the dimensionless frequencies calculated from the input
                   frequencies

    Function takes an array of frequencies and converts to the dimensionless frequency array
    corresponding to a lens with the given redshifted mass. This is given by 8*pi*f*M_lz
    '''

    dim_freq = 8 * np.pi * redshifted_lens_mass * frequency

    return dim_freq

def natural_mass(mass, mode="solar"):
    '''
    Inputs:
        mass - the mass to be converted
        mode - units of the mass given. Can be either "solar" for Solar Masses or "kg"

    Outputs:
        m_nat - the mass in natural units

    Function converts a given mass from either solar masses or kg to natural units
    '''

    #If the mass is in solar masses, first convert to kg
    if mode == "solar":
        m_kg = mass * const.M_sun
    else:
        m_kg = mass

    #Convert from kg to natural units
    m_nat = m_kg * (const.G/const.c**3)

    return m_nat.value
