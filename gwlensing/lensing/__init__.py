from . import utils
import bilby
import numpy as np
import astropy.constants as const

def BBH_lensed_waveform(frequency_array, mass_1, mass_2, a_1, a_2, tilt_1, tilt_2, phi_12, phi_jl, luminosity_distance, theta_jn, phase, ra, dec, geocent_time, psi, lens_mass, impact_parameter, lens_fractional_distance, **kwargs):
    '''
    Inputs:
            frequency_array - frequencies over which to generate waveform
            mass_1 - non-redshifted primary mass in solar masses
            mass_2 - non-redshifted secondary mass in solar masses
            a_1 - primary dimensionless spin magnitude
            a_2 - secondary dimensionless spin magnitude
            tilt_1 - polar angle between primary spin and the orbital angular momentum in radians
            tilt_2 - polar angle between secondary spin and the orbital angular momentum in radians
            phi_12 - azimuthal angle between primary and saecondary spin in radians
            phi_jn - azimuthal angle between total angular momentum and the orbital angular momentum in radians
            luminosity_distance - luminosity distance to source in Mpc
            theta_jn - inclination angle between line of sight and the orbital angular momentum in radians
            phase - phase in radians
            ra - right ascension of the source in radians
            dec - declination of the source in radians
            geocent_time - time of coalesence or peak amplitiude in GPS seconds
            psi - gravitational wave polarisation angle in radians
            lens_mass - the mass of the object doing the lensing in natural units
            impact_parameter - the impact parameter, i.e. the distance between the wave and the lensing object in natural units
            lens_fractional_distance - the fractional position of the lens compared to the source distance.

            **kwargs:
                waveform_approximant - the waveform approximant used to generate the base waveform
                reference_frequency - the waveform reference frequency in Hz
                minimum_frequency - waveform minimum frequency in Hz
                interpolator - the interpolation function that generates the amplification factor to lens the base waveform

        Outputs:
            lens_waveform - dictionary containing the plus and cross polarisation mode strain data for the lensed waveform

        Function takes a base waveform generated by the lal_binary_black_hole function and then lenses it by a lens with redshifted_lens_mass at a distance of impact_parameter with an amplification_factor generated by the interpolator function.'''

    waveform_kwargs = dict(waveform_approximant="IMRPhenomPv2", reference_frequency=50., minimum_frequency=20., interpolator=None)
    waveform_kwargs.update(kwargs)

    waveform_approximant = waveform_kwargs["waveform_approximant"]
    reference_frequency = waveform_kwargs["reference_frequency"]
    minimum_frequency = waveform_kwargs["minimum_frequency"]
    interpolator = waveform_kwargs["interpolator"]

    lens_distance = lens_fractional_distance*luminosity_distance
    lens_redshift = bilby.gw.conversion.luminosity_distance_to_redshift(lens_distance)
    redshifted_lens_mass = natural_mass(lens_mass*(1+lens_redshift))

    base_waveform = bilby.gw.source.lal_binary_black_hole(frequency_array, mass_1=mass_1, mass_2=mass_2, a_1=a_1, a_2=a_2, tilt_1=tilt_1, tilt_2=tilt_2, phi_12=phi_12, phi_jl=phi_jl, luminosity_distance=luminosity_distance, theta_jn=theta_jn, phase=phase, waveform_approximant=waveform_approximant, reference_frequency=reference_frequency, ra=ra, dec=dec, geocent_time=geocent_time, psi=psi)

    if interpolator == None:
        raise ValueError("Interpolator must be given")

    if base_waveform == None:
        return None

    dimensionless_frequency_array = dimensionless_frequency(frequency_array, redshifted_lens_mass)

    lens_array = interpolator(dimensionless_frequency_array, impact_parameter)

    lens_waveform = dict()

    for i in base_waveform:
        lens_waveform[i] = np.multiply(base_waveform[i], lens_array)

    return(lens_waveform)

def dimensionless_frequency(freqs, redshifted_lens_mass):
	'''
	Inputs:
		freqs - frequencies to be converted
		redshifted_lens_mass - Redshifted lens mass of the lens

	Outputs:
		w - dimensionless frequency array 

	Function takes a frequency, or an array of frequencies, and converts to the dimensionless frequency array corresponding to a lens with a certain redshifted lens mass'''

	return(8*np.pi*redshifted_lens_mass*freqs) 

def natural_mass(mass, mode="solar"):
	'''
	Inputs:
		mass - the mass to be converted
		mode - units of the mass given in either "solar" (Solar Masses) or "kg"
	
	Outputs:
		m_nat - the mass in natural units

	Function takes a given value of mass in either solar masses or kg and converts to equivalent natural units'''
		

	if mode == "solar":
		m_kg = mass*const.M_sun
	else:
		m_kg = mass 

	m_nat = m_kg*(const.G/const.c**3) 

	return(m_nat) 
